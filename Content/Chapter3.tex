\chapter{Η Υλοποίηση}
\label{ch:Implementation}

\newcommand{\myTTT}[1]{\texttt{\hyphenchar \font=`\- \spaceskip=.5em plus .5em \xspaceskip=.5em #1}}

Υλοποιήσαμε όλους τους αλγορίθμους που αναφέραμε στο Κεφάλαιο \ref{ch:Algorithms} και σχεδιάσαμε μια γραφική διαπροσωπεία για την οπτικοποίηση της εισόδου και των
αποτελεσμάτων. Η υλοποίηση έγινε στη γλώσσα προγραμματισμού \textbf{Python 3} και η οπτικοποίηση με την βιβλιοθήκη \textbf{PyVis}\cite{pyvis-docs}

\section{Οργάνωση Κώδικα}

Η γενική αρχιτεκτονική για την επίλυση του κάθε αλγορίθμου είναι η ίδια σε κάθε περίπτωση. Πιο συγκεκριμένα η υλοποίηση οργανώνεται στα αρχεία: 
\begin{itemize}
	\item \myTTT{main.py} : η αρχή του εκτελέσιμου προγράμματος.
	
	\item \myTTT{graph.py} : η διευθύνουσα κλάση του γραφήματος.
	
	\item \myTTT{polynomial\_time\_algorithm.py} : η διευθύνουσα κλάση για την υλοποίηση του αλγορίθμου.
	 
\end{itemize} 

Επιπλέον αρχεία υλοποιούν κλάσεις οι οποίες είναι απαραίτητες για την υλοποίηση των επιμέρους αλγορίθμων. Αναλυτικά θα τις αναλύσουμε στις αντίστοιχες ενότητες. 

\section{Είσοδος - Έξοδος}

Κάθε αλγόριθμος που έχουμε υλοποιήσει παίρνει σαν είσοδο ένα AT-free γράφημα. Η αναπαράσταση του γραφήματος έχει γίνει με την κλάση Graph. Έχουμε επιλέξει ο χρήστης μπορεί να ορίσει ένα γράφημα σε αρχείο JSON καθώς η διαχείριση του είναι αρκετά εύκολη από γλώσσες προγραμματισμού όπως η \textbf{Python}. 

Το αρχείο JSON έχει τα κλειδιά "num\_of\_vertices" και "num\_of\_edges" τα οποία δηλώνουν τον αριθμό των κόμβος του γραφήματος και ακμών αντίστοιχα. Οι τιμές που παίρνουν είναι θετική ακέραιοι $\mathbb{N}$. Επιπλέον υπάρχει το κλειδί "edges" το οποίο έχει όλες τις ακμές του γραφήματος. Η δήλωση των ακμών γίνεται με έναν δισδιάστατο πίνακα που περιέχει ζεύγη ακεραίων που υποδηλώνουν τους συνδεδεμένους κόμβους.

Το αρχείο υφίσταται μια ανάλυση προκειμένου να επιβεβαιωθεί η απουσία AT (asteroidal triple). Αυτή η ανάλυση δεν είναι η βέλτιστη αλλά μας διασφαλίζει ότι το γράφημα είναι AT-free. Η κλάση για την ανάλυση του αρχείου:

\lstinputlisting[
language=Python,
breaklines=true,
basicstyle=\footnotesize\ttfamily,
columns=fullflexible,
breakatwhitespace=false,
captionpos=t,
caption={graph\_parser.py}
]{Content/CodeDirectory/graph_parser.py}



Αν η ανάλυση του γραφήματος είναι επιτυχημένη, τότε δημιουργείται ένα αντικείμενο τύπου Graph. Παρακάτω παρουσιάζεται ο ορισμός του Graph, καθώς και τα πεδία που δημιουργούνται. Τα συγκεκριμένα πεδία είναι κοινά και για τους τρεις αλγορίθμους που έχουμε υλοποιήσει. 

  

\begin{lstlisting}[
	language=Python,
	breaklines=true,
	basicstyle=\footnotesize\ttfamily,
	columns=fullflexible,
	breakatwhitespace=false,
	captionpos=t,
	caption={Ορισμός κλάσης Graph},
	label={lst:graph-compiler}
	]
	class Graph:
		def __init__(self, num_of_vertices, 	num_of_edges, edges, vertices=None):
			self.num_of_vertices = num_of_vertices
			self.num_of_edges = num_of_edges
			self.vertices = set(str(i) for i in range(num_of_vertices)) if vertices is None else vertices
			self.edges = set((str(u), str(v)) for u, v in edges)
			self.adjacency_list = {str(vertex): set() for vertex in self.vertices}
			for edge in self.edges:
				u, v = edge
				self.adjacency_list[u].add(v)
				self.adjacency_list[v].add(u)
\end{lstlisting}


Η έξοδος στον αλγόριθμο υπολογισμού μέγιστου ανεξάρτητου συνόλου
είναι ο αριθμός ανεξαρτησίας του γραφήματος καθώς και ένα σετ από κόμβους που είναι ένα μέγιστο ανεξάρτητο σύνολο. 


Ο αλγόριθμος υπολογισμού του ελάχιστου κυρίαρχου συνόλου επιστρέφει ένα σετ κόμβων που αποτελεί ένα ελάχιστο κυρίαρχο σύνολο.  

Για το πρόβλημα του 3-χρωματισμού, η έξοδος του αλγορίθμου παρουσιάζεται σε μορφή λεξικού, όπου κάθε κόμβος του γραφήματος αντιστοιχεί σε ένα κλειδί, και η σχετική τιμή είναι το χρώμα που έχει ανατεθεί σε αυτόν τον κόμβο (π.χ., "red", "green", "blue").

Σε όλους τους αλγορίθμους εκτελούμε την συνάρτηση \myTTT{show()} της κλάσης Graph. Η συνάρτηση επιστρέφει ένα αρχείο HTML το οποίο περιέχει την οπτικοποίηση του γραφήματος.

\section{Δομές Δεδομένων}

Οι δομές που χρησιμοποιήσαμε για την επίλυση των αλγορίθμων είναι δομές που μας παρέχει η γλώσσα προγραμματισμού \textbf{Python}. Η επιλογή των δομών έχει γίνει έτσι ώστε να διατηρήται η χωρική και χρονική πολυπλοκότητα του κάθε αλγορίθμου.

Αρχικά η κλάση Graph \ref{lst:graph-compiler} διαχειρίζεται τις παρακάτω δομές δεδομένων που είναι κοινές και για τους τρεις αλγορίθμους που έχουμε υλοποιήσει:

\begin{enumerate}
	\item πλειάδα \myTTT{tuple}: Οι πλειάδες (tuples) στην \textbf{Python} αποτελούν μια αμετάβλητη δομή δεδομένων  που επιτρέπει την ομαδοποίηση στοιχείων με σειρά. Οι ακμές του γραφήματος αναπαρίστανται ως πλειάδες, δηλαδή ζεύγη ακεραίων αριθμών.
	\item δομή συνόλων \myTTT{set}: Τα σύνολα στην  \textbf{Python} είναι δομές δεδομένων που  αποθηκεύουν μοναδικά στοιχεία, χωρίς να διατηρούν τη σειρά εισαγωγής. Η μοναδικότητα επιτυγχάνεται μέσω της χρήσης hash tables, που επιτρέπουν γρήγορες λειτουργίες εισαγωγής, διαγραφής και αναζήτησης με χρόνο εκτέλεσης $O(1)$ σε μέσο όρο. Κατά τη διάρκεια της εισαγωγής, το στοιχείο υπολογίζει ένα hash value, το οποίο καθορίζει τη θέση του στο hash table. Κατά την αναζήτηση, το hash table χρησιμοποιείται για να εντοπίσει γρήγορα τη θέση του στοιχείου. Παρόλα αυτά, σε περιπτώσεις συγκρούσεων (hash collisions), όπου δύο στοιχεία έχουν το ίδιο hash value, η απόδοση μπορεί να μειωθεί, αυξάνοντας τον χρόνο αναζήτησης στο χειρότερο σενάριο σε $O(n)$. Χρησιμοποιούμε τα σύνολα για να ορίσουμε τους κόμβους και τις ακμές του γραφήματος. 
	\item λεξικό \myTTT{dictionary}: 
	Τα λεξικά στην \textbf{Python} είναι δομές δεδομένων που επιτρέπουν την αποθήκευση και την ανάκτηση δεδομένων με βάση τα κλειδιά. Κάθε κλειδί στο λεξικό είναι μοναδικό και συσχετίζεται με μια τιμή. Η κύρια ιδιότητα των λεξικών είναι η αποδοτική αναζήτηση, καθώς η πρόσβαση σε μια τιμή γίνεται σε σταθερό χρόνο $O(1)$ χάρη στη χρήση hash table. Τα λεξικά μπορούν να περιέχουν διάφορους τύπους δεδομένων ως τιμές, όπως αριθμούς, συμβολοσειρές, λίστες, και ακόμη και άλλα λεξικά. Η ενημέρωση, εισαγωγή, και διαγραφή στοιχείων σε ένα λεξικό γίνεται με διαφορετικές μεθόδους, προσφέροντας μεγάλη ευελιξία στη διαχείριση τους. Χρησιμοποιούμε τα λεξικά για να ορίσουμε τις λίστες γειτνίασης.Κάθε κόμβος (κλειδί) είναι συσχετισμένος με ένα σύνολο από γειτονικούς κόμβους.Η επανάληψη μέσω των ακμών και η ενημέρωση των συνόλων γειτονικών κόμβων είναι γραμμική ως προς τον αριθμό των ακμών. Συνεπώς, ο συνολικός χρόνος εκτέλεσης για τη δημιουργία των λιστών γειτνίασης είναι $O(m)$, όπου $m$ είναι ο αριθμός των ακμών που παρέχονται στη κλάση Graph.
\end{enumerate}

Πιο  συγκεκριμένα θα δούμε τις δομές δεδομένων που χρησιμοποιήσαμε για κάθε αλγόριθμο στις παρακάτω παραγράφους.

Ο Αλγόριθμος υπολογισμός μέγιστου ανεξάρτητου συνόλου \ref{sec:Independent_Set_Alg} χρειάζεται και διαχειρίζεται επιπλέον τις παρακάτω δομές δεδομένων:
\begin{enumerate}
	\item λεξικά: Η κλάση Graph αυτού το αλγορίθμου έχει επιπλέον μεταβλητές για την επίλυση του. Πιο συγκεκριμένα ένα λεξικό για τα $Components$ χρησιμοποιεί ως κλειδί μια πλειάδα, όπου το πρώτο στοιχείο αναφέρεται στον κόμβο προέλευσης, ενώ το δεύτερο στοιχείο (αριθμός i) καθορίζει τη μοναδικότητα του $Component$. Αυτό σημαίνει ότι για κάθε κόμβο, μπορεί να υπάρχουν πολλαπλά $Components$. Η χρήση μιας πλειάδας ως κλειδί επιτρέπει τον εύκολο και γρήγορο προσδιορισμό και ανάκτηση των $Components$ που αντιστοιχούν σε έναν συγκεκριμένο κόμβο. Επιπλέον χρησιμοποιούμε ένα λεξικό το οποίο έχει κλειδιά τους κόμβους $x$ του γραφήματος και σαν τιμές τον αριθμό των $Componentes$ που έχουν στο $G - N[x]$. Αντοίστοιχα για τα $Intervals$ ένα λεξικό με κλειδιά πλειάδες με μη γειτονικές ακμές. Ένα λεξικό που για όλες τις μη γειτονικές κορυφές $x$ και $y$ έχει ως τιμή ένας δείκτης $P(x, y)$ στο $Component$
	του $C^x(y)$. Για την κλάση PolynomialTimeAlgorithm, απαιτούνται δύο επιπλέον λεξικά, τα οποία έχουν κλειδιά παρόμοια με τα λεξικά που διατηρούν τις πληροφορίες για τα $Components$ και τα $Intervals$. Τα νέα λεξικά, λειτουργούν ως αντίγραφα για την αποθήκευση των κόμβων που χρησιμοποιήθηκαν για τον υπολογισμό των μέγιστων τιμών από τους τύπους \ref{lemma6_2} και \ref{lemma6_3}. Η χρήση αυτών των δομών είναι απαραίτητη προκειμένου ο αλγόριθμος να είναι σε θέση να επιστρέψει, εκτός από τον αριθμό ανεξαρτησίας, και το ανεξάρτητο σύνολο που προκύπτει από την εκτέλεση των εν λόγω τύπων.
\end{enumerate}


