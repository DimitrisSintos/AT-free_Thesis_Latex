\chapter{Η Υλοποίηση}
\label{ch:Implementation}

\newcommand{\myTTT}[1]{\texttt{\hyphenchar \font=`\- \spaceskip=.5em plus .5em \xspaceskip=.5em #1}}

Υλοποιήσαμε όλους τους αλγορίθμους που αναφέραμε στο Κεφάλαιο \ref{ch:Algorithms} και σχεδιάσαμε μια γραφική διαπροσωπεία για την οπτικοποίηση της εισόδου και των
αποτελεσμάτων. Η υλοποίηση έγινε στη γλώσσα προγραμματισμού \textbf{Python 3} και η οπτικοποίηση με την βιβλιοθήκη \textbf{PyVis}\cite{pyvis-docs}

\section{Οργάνωση Κώδικα}

Η γενική αρχιτεκτονική για την επίλυση του κάθε αλγορίθμου είναι η ίδια σε κάθε περίπτωση. Πιο συγκεκριμένα η υλοποίηση οργανώνεται στα αρχεία: 
\begin{itemize}
	\item \myTTT{main.py} : η αρχή του εκτελέσιμου προγράμματος.
	
	\item \myTTT{graph.py} : η διευθύνουσα κλάση του γραφήματος.
	
	\item \myTTT{polynomial\_time\_algorithm.py} : η διευθύνουσα κλάση για την υλοποίηση του αλγορίθμου.
	 
\end{itemize} 

Επιπλέον αρχεία υλοποιούν κλάσεις οι οποίες είναι απαραίτητες για την υλοποίηση των επιμέρους αλγορίθμων. Αναλυτικά θα τις αναλύσουμε στις αντίστοιχες ενότητες. 

\section{Είσοδος - Έξοδος}

Κάθε αλγόριθμος που έχουμε υλοποιήσει παίρνει σαν είσοδο ένα AT-free γράφημα. Η αναπαράσταση του γραφήματος έχει γίνει με την κλάση Graph. Έχουμε επιλέξει ο χρήστης μπορεί να ορίσει ένα γράφημα σε αρχείο JSON καθώς η διαχείριση του είναι αρκετά εύκολη από γλώσσες προγραμματισμού όπως η \textbf{Python}. 

Το αρχείο JSON έχει τα κλειδιά "num\_of\_vertices" και "num\_of\_edges" τα οποία δηλώνουν τον αριθμό των κόμβος του γραφήματος και ακμών αντίστοιχα. Οι τιμές που παίρνουν είναι θετική ακέραιοι $\mathbb{N}$. Επιπλέον υπάρχει το κλειδί "edges" το οποίο έχει όλες τις ακμές του γραφήματος. Η δήλωση των ακμών γίνεται με έναν δισδιάστατο πίνακα που περιέχει ζεύγη ακεραίων που υποδηλώνουν τους συνδεδεμένους κόμβους.

Το αρχείο υφίσταται μια ανάλυση προκειμένου να επιβεβαιωθεί η απουσία AT (asteroidal triple). Αυτή η ανάλυση δεν είναι η βέλτιστη αλλά μας διασφαλίζει ότι το γράφημα είναι AT-free. Η κλάση για την ανάλυση του αρχείου:

\lstinputlisting[
language=Python,
breaklines=true,
basicstyle=\footnotesize\ttfamily,
columns=fullflexible,
breakatwhitespace=false,
captionpos=t,
caption={graph\_parser.py}
]{Content/CodeDirectory/graph_parser.py}



Αν η ανάλυση του γραφήματος είναι επιτυχημένη, τότε δημιουργείται ένα αντικείμενο τύπου Graph. Παρακάτω παρουσιάζεται ο ορισμός του Graph, καθώς και τα πεδία που δημιουργούνται. Τα συγκεκριμένα πεδία είναι κοινά και για τους τρεις αλγορίθμους που έχουμε υλοποιήσει. 

  

\begin{lstlisting}[
	language=Python,
	breaklines=true,
	basicstyle=\footnotesize\ttfamily,
	columns=fullflexible,
	breakatwhitespace=false,
	captionpos=t,
	caption={Ορισμός κλάσης Graph},
	label={lst:graph-compiler}
	]
	class Graph:
		def __init__(self, num_of_vertices, 	num_of_edges, edges, vertices=None):
			self.num_of_vertices = num_of_vertices
			self.num_of_edges = num_of_edges
			self.vertices = set(str(i) for i in range(num_of_vertices)) if vertices is None else vertices
			self.edges = set((str(u), str(v)) for u, v in edges)
			self.adjacency_list = {str(vertex): set() for vertex in self.vertices}
			for edge in self.edges:
				u, v = edge
				self.adjacency_list[u].add(v)
				self.adjacency_list[v].add(u)
\end{lstlisting}


Η έξοδος στον αλγόριθμο υπολογισμού μέγιστου ανεξάρτητου συνόλου
είναι ο αριθμός ανεξαρτησίας του γραφήματος καθώς και ένα σετ από κόμβους που είναι ένα μέγιστο ανεξάρτητο σύνολο. 


Ο αλγόριθμος υπολογισμού του ελάχιστου κυρίαρχου συνόλου επιστρέφει ένα σετ κόμβων που αποτελεί ένα ελάχιστο κυρίαρχο σύνολο.  

Για το πρόβλημα του 3-χρωματισμού, η έξοδος του αλγορίθμου παρουσιάζεται σε μορφή λεξικού, όπου κάθε κόμβος του γραφήματος αντιστοιχεί σε ένα κλειδί, και η σχετική τιμή είναι το χρώμα που έχει ανατεθεί σε αυτόν τον κόμβο (π.χ., "red", "green", "blue").

Σε όλους τους αλγορίθμους εκτελούμε την συνάρτηση \myTTT{show()} της κλάσης Graph. Η συνάρτηση επιστρέφει ένα αρχείο HTML το οποίο περιέχει την οπτικοποίηση του γραφήματος.

\section{Δομές Δεδομένων}

Οι δομές που χρησιμοποιήσαμε για την επίλυση των αλγορίθμων είναι δομές που μας παρέχει η γλώσσα προγραμματισμού \textbf{Python}.Η επιλογή των δομών έγινε με σκοπό τη διατήρηση της χωρικής και χρονικής πολυπλοκότητας για κάθε αλγόριθμο. Παρόλο που σε ορισμένες περιπτώσεις θα μπορούσαμε να επιτύχουμε μείωση της χωρικής πολυπλοκότητας εάν είχαμε επιλέξει τη δομή της λίστας αντί του λεξικού, προτιμήσαμε να διατηρήσουμε τη σαφήνεια και την ευανάγνωστη μορφή του κώδικά μας. Κατανοούμε ότι η κατανόηση του κώδικα είναι εξίσου σημαντική με τυχόν οικονομία σε χώρο που θα μπορούσαμε να επιτύχουμε.

Αρχικά η κλάση Graph \ref{lst:graph-compiler} διαχειρίζεται τις παρακάτω δομές δεδομένων που είναι κοινές και για τους τρεις αλγορίθμους που έχουμε υλοποιήσει:

\begin{enumerate}
	\item πλειάδα \myTTT{tuple}: Οι πλειάδες (tuples) στην \textbf{Python} αποτελούν μια αμετάβλητη δομή δεδομένων  που επιτρέπει την ομαδοποίηση στοιχείων με σειρά. Οι ακμές του γραφήματος αναπαρίστανται ως πλειάδες, δηλαδή ζεύγη ακεραίων αριθμών.
	\item δομή συνόλων \myTTT{set}: Τα σύνολα στην  \textbf{Python} είναι δομές δεδομένων που  αποθηκεύουν μοναδικά στοιχεία, χωρίς να διατηρούν τη σειρά εισαγωγής. Η μοναδικότητα επιτυγχάνεται μέσω της χρήσης hash tables, που επιτρέπουν γρήγορες λειτουργίες εισαγωγής, διαγραφής και αναζήτησης με χρόνο εκτέλεσης $O(1)$ σε μέσο όρο. Κατά τη διάρκεια της εισαγωγής, το στοιχείο υπολογίζει ένα hash value, το οποίο καθορίζει τη θέση του στο hash table. Κατά την αναζήτηση, το hash table χρησιμοποιείται για να εντοπίσει γρήγορα τη θέση του στοιχείου. Παρόλα αυτά, σε περιπτώσεις συγκρούσεων (hash collisions), όπου δύο στοιχεία έχουν το ίδιο hash value, η απόδοση μπορεί να μειωθεί, αυξάνοντας τον χρόνο αναζήτησης στο χειρότερο σενάριο σε $O(n)$. Χρησιμοποιούμε τα σύνολα για να ορίσουμε τους κόμβους και τις ακμές του γραφήματος. 
	\item λεξικό \myTTT{dictionary}: 
	Τα λεξικά στην \textbf{Python} είναι δομές δεδομένων που επιτρέπουν την αποθήκευση και την ανάκτηση δεδομένων με βάση τα κλειδιά. Κάθε κλειδί στο λεξικό είναι μοναδικό και συσχετίζεται με μια τιμή. Η κύρια ιδιότητα των λεξικών είναι η αποδοτική αναζήτηση, καθώς η πρόσβαση σε μια τιμή γίνεται σε σταθερό χρόνο $O(1)$ χάρη στη χρήση hash table. Τα λεξικά μπορούν να περιέχουν διάφορους τύπους δεδομένων ως τιμές, όπως αριθμούς, συμβολοσειρές, λίστες, και ακόμη και άλλα λεξικά. Η ενημέρωση, εισαγωγή, και διαγραφή στοιχείων σε ένα λεξικό γίνεται με διαφορετικές μεθόδους, προσφέροντας μεγάλη ευελιξία στη διαχείριση τους. Χρησιμοποιούμε τα λεξικά για να ορίσουμε τις λίστες γειτνίασης. Κάθε κόμβος (κλειδί) είναι συσχετισμένος με ένα σύνολο από γειτονικούς κόμβους. Η επανάληψη μέσω των ακμών και η ενημέρωση των συνόλων γειτονικών κόμβων είναι γραμμική ως προς τον αριθμό των ακμών. Συνεπώς, ο συνολικός χρόνος εκτέλεσης για τη δημιουργία των λιστών γειτνίασης είναι $O(m)$, όπου $m$ είναι ο αριθμός των ακμών που παρέχονται στη κλάση Graph.
\end{enumerate}

Πιο  συγκεκριμένα θα δούμε τις δομές δεδομένων που χρησιμοποιήσαμε για κάθε αλγόριθμο στις παρακάτω παραγράφους.

Ο Αλγόριθμος υπολογισμός μέγιστου ανεξάρτητου συνόλου \ref{sec:Independent_Set_Alg} χρειάζεται και διαχειρίζεται επιπλέον τις παρακάτω δομές δεδομένων:
\begin{enumerate}
	\item λεξικά: Η κλάση Graph αυτού το αλγορίθμου έχει επιπλέον μεταβλητές για την επίλυση του. Πιο συγκεκριμένα ένα λεξικό για τα $Components$ χρησιμοποιεί ως κλειδί μια πλειάδα, όπου το πρώτο στοιχείο αναφέρεται στον κόμβο προέλευσης, ενώ το δεύτερο στοιχείο (αριθμός i) καθορίζει τη μοναδικότητα του $Component$. Αυτό σημαίνει ότι για κάθε κόμβο, μπορεί να υπάρχουν πολλαπλά $Components$. Η χρήση μιας πλειάδας ως κλειδί επιτρέπει τον εύκολο και γρήγορο προσδιορισμό και ανάκτηση των $Components$ που αντιστοιχούν σε έναν συγκεκριμένο κόμβο. Επιπλέον χρησιμοποιούμε ένα λεξικό το οποίο έχει κλειδιά τους κόμβους $x$ του γραφήματος και σαν τιμές τον αριθμό των $Componentes$ που έχουν στο $G - N[x]$. Αντίστοιχα για τα $Intervals$ ένα λεξικό με κλειδιά πλειάδες με μη γειτονικές ακμές. Ένα λεξικό που για όλες τις μη γειτονικές κορυφές $x$ και $y$ έχει ως τιμή ένας δείκτης $P(x, y)$ στο $Component$
	του $C^x(y)$. Για την κλάση PolynomialTimeAlgorithm, απαιτούνται δύο επιπλέον λεξικά, τα οποία έχουν κλειδιά παρόμοια με τα λεξικά που διατηρούν τις πληροφορίες για τα $Components$ και τα $Intervals$. Τα νέα λεξικά, λειτουργούν ως αντίγραφα για την αποθήκευση των κόμβων που χρησιμοποιήθηκαν για τον υπολογισμό των μέγιστων τιμών από τους τύπους \ref{lemma6_2} και \ref{lemma6_3}. Η χρήση αυτών των δομών είναι απαραίτητη προκειμένου ο αλγόριθμος να είναι σε θέση να επιστρέψει, εκτός από τον αριθμό ανεξαρτησίας, και το ανεξάρτητο σύνολο που προκύπτει από την εκτέλεση των εν λόγω τύπων.
\end{enumerate}

Για τον Αλγόριθμο υπολογισμού ελάχιστου κυρίαρχου συνόλου \ref{sec:Domination_Set_Alg} χρειάζεται η παρακάτω δομή δεδομένων:
\begin{enumerate}
	\item λεξικά: Στην κλάση PolynomialTimeAlgorithm όπου υλοποιούμε τον αλγόριθμο έχουμε αναπαραστήσει την δομή $H$, η οποία 
	διατηρεί τα BFS-levels του γραφήματος για κάποιον κόμβο $x \in V$, με ένα λεξικό. Το $Η$ παίρνει ως κλειδί έναν θετικό ακέραιο που δηλώνει το επίπεδο του BFS και σαν τιμή ένα σύνολο \myTTT{set} με τους κόμβους που υπάρχουν στο εκάστοτε επίπεδο. 
	
	Επιπλέον ένα λεξικό για να ορίσουμε την δομή $A$ όπου σαν κλειδί έχει τον αριθμό $i$ σε κάθε βρόχο της εκτέλεση του αλγορίθμου και σαν τιμή έχει μια ουρά που περιέχει μια ταξινομημένη πλειάδα $(S, S, val(S))$.
\end{enumerate}

Τέλος για την επίλυση του Πρόβληματος 3-Χρωματισμού χρησιμοποιήσαμε επιπλέον τις δομές:
 
\begin{enumerate}
	\item λεξικό: Στην κλάση Graph χρειαστήκαμε μια δομή λεξικού για να αποθηκεύει τα $Blocks$ του γραφήματος.
	
	\item σύνολο: Για τον χρωματισμό του γραφήματος χρειάστηκε να αποθηκεύσουμε σε ένα σύνολο τα $cutpoints$ του.
\end{enumerate}

\section{Υπολογισμός Μέγιστου Ανεξάρτητου Συνόλου}
\label{sec:Impl-Independent-set}
%ο Αλγόριθμος "Biconnectivity" του Robert Tarjan \cite{tarjan-depth-first-search}

Στο παρόν κεφάλαιο, παρουσιάζουμε ενδεικτικές κλάσεις που αποτελούν το αλγοριθμικό τμήμα για τον υπολογισμό του μέγιστου ανεξάρτητου συνόλου. Προχωρούμε στην παρουσίαση αυτών των κλάσεων με τη σειρά που καλούνται στο πλαίσιο του συνολικού αλγοριθμικού σχεδιασμού. Σημειώνουμε πως παραλείπουμε τις κλάσεις που υλοποιούν αλγορίθμους από άλλες εργασίες, όπως ο αλγόριθμος του Bucket sort.

\captionsetup[lstlisting]{labelformat = empty}

\subsection{H Kλάση PolynomialTimeAlgorithm}
\label{subsec:PolynomialTimeAlgorithm-IndependentSet}
Η κλάση \myTTT{PolynomialTimeAlgorithm} αποτελεί την κύρια κλάση για τον υπολογισμό του μέγιστου ανεξάρτητου συνόλου.


%---------------FILE---------------------------------

\lstinputlisting[
    language=Python,
    breaklines=true,
    basicstyle=\footnotesize\ttfamily,
    columns=fullflexible,
    breakatwhitespace=false,
    captionpos=t,
    caption={polynomial\_time\_algorithm.py}
]{Content/CodeDirectory/polynomial_time_algorithm_independent_set.py}
%---------------FILE END---------------------------------

Εξηγούμε αναλυτικά τις συναρτήσεις την κλάσεις:

\begin{enumerate}
	\item Κατασκευαστής (\_\_init\_\_): Δέχεται ένα αντικείμενο  graph και αρχικοποιεί τα χαρακτηριστικά της κλάσης, όπως τα σύνολα "max\_interval\_vertices\_set" και "max\_component\_vertices\_set".
	\item H συνάρτηση \myTTT{computing\_independent\_set}: Είναι η κύρια συνάρτηση που εκτελεί τα βήματα του αλγορίθμου για τον υπολογισμό του μέγιστου ανεξάρτητου συνόλου.
	\item Η συνάρτηση \myTTT{alpha\_C}: Υλοποιεί το λήμμα \ref{lemma6_3}.
	\item H συνάρτηση \myTTT{alpha\_I}: Υλοποιεί το λήμμα \ref{lemma6_2}.
	\item H συνάρτηση \myTTT{alpha\_G}: Υλοποιεί το λήμμα \ref{lemma6_1}.
	\item Η συνάρτηση \myTTT{compute\_components\_subset} λαμβάνει ως είσοδο έναν κόμβο \myTTT{vertex}, ένα σύνολο κορυφών \myTTT{target\_vertices}, και τον αριθμό των $Components$ που πρέπει να εξεταστούν \myTTT{num\_components}. Επιστρέφει μια λίστα με τα κλειδιά των $Components$ που ανήκουν στο σύνολο \myTTT{target\_vertices}. Αυτή η λειτουργία είναι κρίσιμη για τον υπολογισμό των ανεξάρτητων συνόλων στη βάση των Λημμάτων \ref{lemma6_2} και \ref{lemma6_3}.
	\item Η συνάρτηση \myTTT{compute\_D\_iy} χρησιμοποιεί την \myTTT{compute\_components\_subset} για να υπολογίσει τις συνιστώσες \myTTT{D\_iy}, δηλαδή εκείνες που περιέχονται στο \myTTT{Cx\_vertices} και ανήκουν στη γειτονιά του \myTTT{y}. Η είσοδος αυτής της συνάρτησης περιλαμβάνει τον κόμβο \myTTT{y} και το υποσύνολο κορυφών \myTTT{Cx\_vertices}, ενώ η έξοδός της είναι η λίστα των $Components$ \myTTT{D\_iy}.
	\item Η συνάρτηση \myTTT{compute\_C\_is} λειτουργεί παρόμοια με την \myTTT{compute\_D\_iy}, αλλά χρησιμοποιείται για τον υπολογισμό των $Components$ \myTTT{C\_is}, που περιέχονται στο \myTTT{I\_vertices} και ανήκουν στη γειτονιά του \myTTT{s}. Η είσοδος περιλαμβάνει τον κόμβο \myTTT{s} και το υποσύνολο κορυφών \myTTT{I\_vertices}, ενώ η έξοδός της είναι η λίστα των $Components$ \myTTT{C\_is}.
\end{enumerate}
\subsection{H Kλάση Graph}

\lstinputlisting[
language=Python,
breaklines=true,
basicstyle=\footnotesize\ttfamily,
columns=fullflexible,
breakatwhitespace=false,
captionpos=t,
caption={graph.py}
]{Content/CodeDirectory/graph_independent_set.py}
%---------------FILE END---------------------------------


